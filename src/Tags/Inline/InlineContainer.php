<?php

declare(strict_types=1);

namespace Lsa\Xsl\Core\Tags\Inline;

use Lsa\Xsl\Core\Contracts\HasAuralFallback;
use Lsa\Xsl\Core\Contracts\HasVisualFallback;
use Lsa\Xsl\Core\Tags\Layout\Root;
use Lsa\Xsl\Core\Traits\ExtendedAuralConformance;
use Lsa\Xsl\Core\Traits\ExtendedVisualConformance;
use Lsa\Xsl\Core\Validation\Tags\InlineContainer as ValidateInlineContainer;
use Lsa\Xsl\Core\Xml\Tag;

/**
 * The fo:inline-container flow object is used to generate an inline reference-area, typically containing text
 * blocks with a different writing-mode.
 *
 * Note:
 * The use of this flow object is not required for bi-directional text; in this case the Unicode BIDI algorithm
 * and the fo:bidi-override are sufficient.
 *
 * Areas:
 * The fo:inline-container formatting object generates one or more viewport/reference pairs. All generated
 * viewport-areas are subject to the constraints given by the block-progression-dimension and
 * inline-progression-dimension traits of the fo:inline-container. The fo:inline-container returns these areas
 * and any page-level-out-of-line areas returned by the children of the fo:inline-container.
 *
 * Note:
 * In the case that the block-progression-dimension.maximum is other than "auto", then overflow processing may
 * apply. The "repeat" value of overflow can be used to generate multiple viewport/reference pairs if this is
 * desired rather than clipping or scrolling.
 *
 * If the absolute-position trait is "auto", these areas all have an area-class of "xsl-normal". If the
 * absolution-position trait is "absolute" or "fixed" then there is one viewport/reference pair, and its
 * area-class is "xsl-absolute" or "xsl-fixed", respectively.
 *
 * Trait Derivation:
 * The reference-orientation and writing-mode traits of the viewport-area and reference-area come from the
 * fo:inline-container. These determine the orientation of the start-edge, end-edge, before-edge and after-edge
 * of the content-rectangle of the viewport-area, and of the padding-, border-, and content-rectangles of the
 * reference-area. The reference-orientation of the reference-area is set to "0" and is, therefore, the same as
 * the orientation established by the viewport-area. The inline-progression-dimension of the reference-area is
 * the same as that of the viewport-area, and may not be "auto" if the inline-progression-direction is
 * different from that of the parent of the fo:inline-container. The block-progression-dimension of the
 * reference-area is not constrained; thus the reference-area may be larger than the viewport-area and this may
 * cause the "overflow" property to operate.
 *
 * Note:
 * As a property value applies to each of the areas generated by this flow object the size can vary from
 * instance to instance if the value is "auto" or a <length-range>.
 *
 * The values in the baseline-table of this object are calculated as follows:
 *
 * baseline
 * - If the writing mode has a block-progression-direction that is parallel to the block-progression-direction
 *   of the parent: the alignment-point is at the position of the dominant-baseline of the first descendant
 *   line-area. If there is no such line-area the alignment-point is at the position of the after-edge of the
 *   allocation rectangle.
 * - If the writing mode has a block-progression-direction that is not parallel to the
 *   block-progression-direction of the parent: the alignment-point is at the position that is half way between
 *   the before-edge and after-edge of the content rectangle.
 *
 * before-edge
 * - The alignment-point is at the position of the before-edge of the allocation rectangle.
 *
 * text-before-edge
 * - The alignment-point is at the position that is the closest to the before-edge of the allocation rectangle
 *   selected from the two candidate edges. If the writing mode has a block-progression-direction that is
 *   parallel to the block-progression-direction of the parent the candidate edges are the before-edge and the
 *   after-edge of the content rectangle; if it is not, the candidate edges are the start-edge and the end-edge
 *   of the content rectangle.
 *
 * middle
 * - The alignment-point is at the position that is half way between the before-edge and after-edge of the
 *   allocation rectangle.
 *
 * after-edge
 * - The alignment-point is at the position of the after-edge of the allocation rectangle.
 *
 * text-after-edge
 * - The alignment-point is at the position that is the closest to the after-edge of the allocation rectangle
 *   selected from the two candidate edges. If the writing mode has a block-progression-direction that is
 *   parallel to the block-progression-direction of the parent the candidate edges are the before-edge and the
 *   after-edge of the content rectangle; if it is not, the candidate edges are the start-edge and the end-edge
 *   of the content rectangle.
 *
 * ideographic
 * - The alignment-point is at the position that is 7/10 of the distance from the before-edge of the allocation
 *   rectangle to the after-edge of the allocation rectangle.
 *
 * alphabetic
 * - The alignment-point is at the position that is 6/10 of the distance from the before-edge of the allocation
 *   rectangle to the after-edge of the allocation rectangle.
 *
 * hanging
 * - The alignment-point is at the position that is 2/10 of the distance from the before-edge of the allocation
 *   rectangle to the after-edge of the allocation rectangle.
 *
 * mathematical
 * - The alignment-point is at the position that is 5/10 of the distance from the before-edge of the allocation
 *   rectangle to the after-edge of the allocation rectangle.
 *
 * Constraints:
 * No area may have more than one normal child area returned by the same fo:inline-container formatting object.
 * The children of each reference-area generated by an fo:inline-container formatting object must be normal
 * block-areas returned by the children of the fo:inline-container, must be properly stacked, and must be
 * properly ordered.
 * Any reference-level-out-of-line areas returned by the children of the fo:inline-container are handled as
 * described in 6.12.2 fo:float.
 *
 * @see \Lsa\Xsl\Core\Tags\OutOfLine\FloatElement
 *
 * Contents:
 * (%block;)+
 *
 * In addition this formatting object may have a sequence of zero or more fo:markers as its initial children.
 * @see https://www.w3.org/TR/xsl11/#fo_inline-container
 */
class InlineContainer extends Tag implements HasAuralFallback, HasVisualFallback
{
    use ExtendedAuralConformance;
    use ExtendedVisualConformance;
    use ValidateInlineContainer;

    public function getVisualFallback(Root $root): ?Tag
    {
        // Fallback: display an indication that content cannot be correctly rendered.
        return new Inline('This content cannot be correctly rendered');
    }

    public function getAuralFallback(Root $root): ?Tag
    {
        // Fallback: speak an indication that content cannot be correctly spoken.
        return new Inline('This content cannot be correctly spoken');
    }
}
